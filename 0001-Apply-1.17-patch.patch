From c76faf0fa804e8487cfbe1ec286543adef441216 Mon Sep 17 00:00:00 2001
From: Will Hickey <will.hickey@anza.xyz>
Date: Sun, 11 Feb 2024 05:00:28 +0000
Subject: [PATCH] Apply 1.17 patch

---
 core/src/banking_stage/consumer.rs     |   3 +-
 program-runtime/src/loaded_programs.rs | 323 +++++++++++++++++++------
 runtime/src/bank.rs                    |  41 +++-
 3 files changed, 279 insertions(+), 88 deletions(-)

diff --git a/core/src/banking_stage/consumer.rs b/core/src/banking_stage/consumer.rs
index ebdfeeacf0..c8624a96aa 100644
--- a/core/src/banking_stage/consumer.rs
+++ b/core/src/banking_stage/consumer.rs
@@ -554,7 +554,8 @@ impl Consumer {
                 transaction_status_sender_enabled,
                 &mut execute_and_commit_timings.execute_timings,
                 None, // account_overrides
-                self.log_messages_bytes_limit
+                self.log_messages_bytes_limit,
+                true,
             ));
         execute_and_commit_timings.load_execute_us = load_execute_us;
 
diff --git a/program-runtime/src/loaded_programs.rs b/program-runtime/src/loaded_programs.rs
index f353e361bb..f9505e1c83 100644
--- a/program-runtime/src/loaded_programs.rs
+++ b/program-runtime/src/loaded_programs.rs
@@ -193,7 +193,7 @@ impl Stats {
             ("reloads", reloads, i64),
             ("insertions", insertions, i64),
             ("lost_insertions", lost_insertions, i64),
-            ("replacements", replacements, i64),
+            ("replace_entry", replacements, i64),
             ("one_hit_wonders", one_hit_wonders, i64),
             ("prunes_orphan", prunes_orphan, i64),
             ("prunes_environment", prunes_environment, i64),
@@ -553,6 +553,7 @@ pub struct LoadedProgramsForTxBatch {
     entries: HashMap<Pubkey, Arc<LoadedProgram>>,
     slot: Slot,
     pub environments: ProgramRuntimeEnvironments,
+    pub hit_max_limit: bool,
 }
 
 impl LoadedProgramsForTxBatch {
@@ -561,6 +562,7 @@ impl LoadedProgramsForTxBatch {
             entries: HashMap::new(),
             slot,
             environments,
+            hit_max_limit: false,
         }
     }
 
@@ -645,59 +647,101 @@ impl<FG: ForkGraph> LoadedPrograms<FG> {
 
     /// Refill the cache with a single entry. It's typically called during transaction loading,
     /// when the cache doesn't contain the entry corresponding to program `key`.
-    /// The function dedupes the cache, in case some other thread replenished the entry in parallel.
     pub fn replenish(
         &mut self,
         key: Pubkey,
         entry: Arc<LoadedProgram>,
+        current_slot: Slot,
     ) -> (bool, Arc<LoadedProgram>) {
         let slot_versions = &mut self.entries.entry(key).or_default().slot_versions;
-        let index = slot_versions
-            .iter()
-            .position(|at| at.effective_slot >= entry.effective_slot);
-        if let Some(existing) = index.and_then(|index| slot_versions.get_mut(index)) {
-            if existing.deployment_slot == entry.deployment_slot
-                && existing.effective_slot == entry.effective_slot
-            {
-                if matches!(existing.program, LoadedProgramType::Unloaded(_)) {
-                    // The unloaded program is getting reloaded
-                    // Copy over the usage counter to the new entry
-                    entry.tx_usage_counter.fetch_add(
-                        existing.tx_usage_counter.load(Ordering::Relaxed),
-                        Ordering::Relaxed,
-                    );
-                    entry.ix_usage_counter.fetch_add(
-                        existing.ix_usage_counter.load(Ordering::Relaxed),
-                        Ordering::Relaxed,
-                    );
-                    self.stats.reloads.fetch_add(1, Ordering::Relaxed);
-                } else if existing.is_tombstone() != entry.is_tombstone() {
-                    // Either the old entry is tombstone and the new one is not.
-                    // (Let's give the new entry a chance).
-                    // Or, the old entry is not a tombstone and the new one is a tombstone.
-                    // (Remove the old entry, as the tombstone makes it obsolete).
+        if current_slot > 247806000 {
+            match slot_versions.binary_search_by(|at| {
+                at.effective_slot
+                    .cmp(&entry.effective_slot)
+                    .then(at.deployment_slot.cmp(&entry.deployment_slot))
+            }) {
+                Ok(index) => {
+                    let existing = slot_versions.get_mut(index).unwrap();
+                    if std::mem::discriminant(&existing.program)
+                        != std::mem::discriminant(&entry.program)
+                    {
+                        // Copy over the usage counter to the new entry
+                        entry.tx_usage_counter.fetch_add(
+                            existing.tx_usage_counter.load(Ordering::Relaxed),
+                            Ordering::Relaxed,
+                        );
+                        entry.ix_usage_counter.fetch_add(
+                            existing.ix_usage_counter.load(Ordering::Relaxed),
+                            Ordering::Relaxed,
+                        );
+                        self.stats.reloads.fetch_add(1, Ordering::Relaxed);
+                        *existing = entry.clone();
+                        (false, entry)
+                    } else {
+                        // Something is wrong, I can feel it ...
+                        self.stats.replacements.fetch_add(1, Ordering::Relaxed);
+                        (true, existing.clone())
+                    }
+                }
+                Err(index) => {
                     self.stats.insertions.fetch_add(1, Ordering::Relaxed);
-                } else {
-                    self.stats.replacements.fetch_add(1, Ordering::Relaxed);
-                    return (true, existing.clone());
+                    slot_versions.insert(index, entry.clone());
+                    (false, entry)
                 }
-                *existing = entry.clone();
-                return (false, entry);
             }
+        } else {
+            let index = slot_versions
+                .iter()
+                .position(|at| at.effective_slot >= entry.effective_slot);
+            if let Some(existing) = index.and_then(|index| slot_versions.get_mut(index)) {
+                if existing.deployment_slot == entry.deployment_slot
+                    && existing.effective_slot == entry.effective_slot
+                {
+                    if matches!(existing.program, LoadedProgramType::Unloaded(_)) {
+                        // The unloaded program is getting reloaded
+                        // Copy over the usage counter to the new entry
+                        entry.tx_usage_counter.fetch_add(
+                            existing.tx_usage_counter.load(Ordering::Relaxed),
+                            Ordering::Relaxed,
+                        );
+                        entry.ix_usage_counter.fetch_add(
+                            existing.ix_usage_counter.load(Ordering::Relaxed),
+                            Ordering::Relaxed,
+                        );
+                        self.stats.reloads.fetch_add(1, Ordering::Relaxed);
+                    } else if existing.is_tombstone() != entry.is_tombstone() {
+                        // Either the old entry is tombstone and the new one is not.
+                        // (Let's give the new entry a chance).
+                        // Or, the old entry is not a tombstone and the new one is a tombstone.
+                        // (Remove the old entry, as the tombstone makes it obsolete).
+                        self.stats.insertions.fetch_add(1, Ordering::Relaxed);
+                    } else {
+                        self.stats.replacements.fetch_add(1, Ordering::Relaxed);
+                        return (true, existing.clone());
+                    }
+                    *existing = entry.clone();
+                    return (false, entry);
+                }
+            }
+            self.stats.insertions.fetch_add(1, Ordering::Relaxed);
+            slot_versions.insert(index.unwrap_or(slot_versions.len()), entry.clone());
+            (false, entry)
         }
-        self.stats.insertions.fetch_add(1, Ordering::Relaxed);
-        slot_versions.insert(index.unwrap_or(slot_versions.len()), entry.clone());
-        (false, entry)
     }
 
     /// Assign the program `entry` to the given `key` in the cache.
     /// This is typically called when a deployed program is managed (un-/re-/deployed) via
     /// loader instructions. Because of the cooldown, entires can not have the same
     /// deployment_slot and effective_slot.
-    pub fn assign_program(&mut self, key: Pubkey, entry: Arc<LoadedProgram>) -> Arc<LoadedProgram> {
-        let (was_occupied, entry) = self.replenish(key, entry);
+    pub fn assign_program(
+        &mut self,
+        key: Pubkey,
+        entry: Arc<LoadedProgram>,
+        current_slot: Slot,
+    ) -> (bool, Arc<LoadedProgram>) {
+        let (was_occupied, entry) = self.replenish(key, entry, current_slot);
         debug_assert!(!was_occupied);
-        entry
+        (was_occupied, entry)
     }
 
     pub fn prune_by_deployment_slot(&mut self, slot: Slot) {
@@ -943,7 +987,7 @@ impl<FG: ForkGraph> LoadedPrograms<FG> {
         slot: Slot,
         key: Pubkey,
         loaded_program: Arc<LoadedProgram>,
-    ) {
+    ) -> bool {
         let second_level = self.entries.entry(key).or_default();
         debug_assert_eq!(
             second_level.cooperative_loading_lock,
@@ -966,13 +1010,14 @@ impl<FG: ForkGraph> LoadedPrograms<FG> {
         {
             self.stats.lost_insertions.fetch_add(1, Ordering::Relaxed);
         }
-        self.assign_program(key, loaded_program);
+        let (was_replaced, _) = self.assign_program(key, loaded_program, slot);
         self.loading_task_waiter.notify();
+        was_replaced
     }
 
     pub fn merge(&mut self, tx_batch_cache: &LoadedProgramsForTxBatch) {
         tx_batch_cache.entries.iter().for_each(|(key, entry)| {
-            self.replenish(*key, entry.clone());
+            self.replenish(*key, entry.clone(), tx_batch_cache.slot);
         })
     }
 
@@ -1190,7 +1235,13 @@ mod tests {
         slot: Slot,
         reason: LoadedProgramType,
     ) -> Arc<LoadedProgram> {
-        cache.assign_program(key, Arc::new(LoadedProgram::new_tombstone(slot, reason)))
+        cache
+            .assign_program(
+                key,
+                Arc::new(LoadedProgram::new_tombstone(slot, reason)),
+                u64::MAX,
+            )
+            .1
     }
 
     fn insert_unloaded_program<FG: ForkGraph>(
@@ -1213,7 +1264,7 @@ mod tests {
             .to_unloaded()
             .expect("Failed to unload the program"),
         );
-        cache.replenish(key, unloaded).1
+        cache.replenish(key, unloaded, u64::MAX).1
     }
 
     fn num_matching_entries<P, FG>(cache: &LoadedPrograms<FG>, predicate: P) -> usize
@@ -1255,6 +1306,7 @@ mod tests {
                         (*deployment_slot) + 2,
                         AtomicU64::new(usage_counter),
                     ),
+                    u64::MAX,
                 );
                 programs.push((program1, *deployment_slot, usage_counter));
             });
@@ -1288,6 +1340,7 @@ mod tests {
                         (*deployment_slot) + 2,
                         AtomicU64::new(usage_counter),
                     ),
+                    u64::MAX,
                 );
                 programs.push((program2, *deployment_slot, usage_counter));
             });
@@ -1320,6 +1373,7 @@ mod tests {
                         (*deployment_slot) + 2,
                         AtomicU64::new(usage_counter),
                     ),
+                    u64::MAX,
                 );
                 programs.push((program3, *deployment_slot, usage_counter));
             });
@@ -1409,6 +1463,7 @@ mod tests {
             cache.replenish(
                 program,
                 new_test_loaded_program_with_usage(i, i + 2, AtomicU64::new(i + 10)),
+                u64::MAX,
             );
         });
 
@@ -1436,6 +1491,7 @@ mod tests {
         cache.replenish(
             program,
             new_test_loaded_program_with_usage(0, 2, AtomicU64::new(0)),
+            u64::MAX,
         );
 
         cache.entries.values().for_each(|second_level| {
@@ -1464,7 +1520,7 @@ mod tests {
         );
 
         let loaded_program = new_test_loaded_program(10, 10);
-        let (existing, program) = cache.replenish(program1, loaded_program.clone());
+        let (existing, program) = cache.replenish(program1, loaded_program.clone(), u64::MAX);
         assert!(!existing);
         assert_eq!(program, loaded_program);
     }
@@ -1506,7 +1562,7 @@ mod tests {
         let program2 = Pubkey::new_unique();
         assert!(
             !cache
-                .replenish(program2, new_test_builtin_program(50, 51))
+                .replenish(program2, new_test_builtin_program(50, 51), u64::MAX)
                 .0
         );
         let second_level = &cache
@@ -1609,7 +1665,7 @@ mod tests {
 
         let program1 = Pubkey::new_unique();
         let loaded_program = new_test_loaded_program(10, 10);
-        let (existing, program) = cache.replenish(program1, loaded_program.clone());
+        let (existing, program) = cache.replenish(program1, loaded_program.clone(), u64::MAX);
         assert!(!existing);
         assert_eq!(program, loaded_program);
 
@@ -1627,7 +1683,7 @@ mod tests {
             tx_usage_counter: AtomicU64::default(),
             ix_usage_counter: AtomicU64::default(),
         });
-        let (existing, program) = cache.replenish(program1, updated_program.clone());
+        let (existing, program) = cache.replenish(program1, updated_program.clone(), u64::MAX);
         assert!(!existing);
         assert_eq!(program, updated_program);
 
@@ -1780,36 +1836,70 @@ mod tests {
         cache.set_fork_graph(fork_graph);
 
         let program1 = Pubkey::new_unique();
-        assert!(!cache.replenish(program1, new_test_loaded_program(0, 1)).0);
-        assert!(!cache.replenish(program1, new_test_loaded_program(10, 11)).0);
-        assert!(!cache.replenish(program1, new_test_loaded_program(20, 21)).0);
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(0, 1), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(10, 11), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(20, 21), u64::MAX)
+                .0
+        );
 
         // Test: inserting duplicate entry return pre existing entry from the cache
-        assert!(cache.replenish(program1, new_test_loaded_program(20, 21)).0);
+        assert!(
+            cache
+                .replenish(program1, new_test_loaded_program(20, 21), u64::MAX)
+                .0
+        );
 
         let program2 = Pubkey::new_unique();
-        assert!(!cache.replenish(program2, new_test_loaded_program(5, 6)).0);
+        assert!(
+            !cache
+                .replenish(program2, new_test_loaded_program(5, 6), u64::MAX)
+                .0
+        );
         assert!(
             !cache
                 .replenish(
                     program2,
-                    new_test_loaded_program(11, 11 + DELAY_VISIBILITY_SLOT_OFFSET)
+                    new_test_loaded_program(11, 11 + DELAY_VISIBILITY_SLOT_OFFSET),
+                    u64::MAX
                 )
                 .0
         );
 
         let program3 = Pubkey::new_unique();
-        assert!(!cache.replenish(program3, new_test_loaded_program(25, 26)).0);
+        assert!(
+            !cache
+                .replenish(program3, new_test_loaded_program(25, 26), u64::MAX)
+                .0
+        );
 
         let program4 = Pubkey::new_unique();
-        assert!(!cache.replenish(program4, new_test_loaded_program(0, 1)).0);
-        assert!(!cache.replenish(program4, new_test_loaded_program(5, 6)).0);
+        assert!(
+            !cache
+                .replenish(program4, new_test_loaded_program(0, 1), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program4, new_test_loaded_program(5, 6), u64::MAX)
+                .0
+        );
         // The following is a special case, where effective slot is 3 slots in the future
         assert!(
             !cache
                 .replenish(
                     program4,
-                    new_test_loaded_program(15, 15 + DELAY_VISIBILITY_SLOT_OFFSET)
+                    new_test_loaded_program(15, 15 + DELAY_VISIBILITY_SLOT_OFFSET),
+                    u64::MAX
                 )
                 .0
         );
@@ -1935,7 +2025,7 @@ mod tests {
             tx_usage_counter: AtomicU64::default(),
             ix_usage_counter: AtomicU64::default(),
         });
-        assert!(!cache.replenish(program4, test_program).0);
+        assert!(!cache.replenish(program4, test_program, u64::MAX).0);
 
         // Testing fork 0 - 5 - 11 - 15 - 16 - 19 - 21 - 23 with current slot at 19
         let mut missing = vec![
@@ -2088,15 +2178,35 @@ mod tests {
         cache.set_fork_graph(fork_graph);
 
         let program1 = Pubkey::new_unique();
-        assert!(!cache.replenish(program1, new_test_loaded_program(0, 1)).0);
-        assert!(!cache.replenish(program1, new_test_loaded_program(20, 21)).0);
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(0, 1), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(20, 21), u64::MAX)
+                .0
+        );
 
         let program2 = Pubkey::new_unique();
-        assert!(!cache.replenish(program2, new_test_loaded_program(5, 6)).0);
-        assert!(!cache.replenish(program2, new_test_loaded_program(11, 12)).0);
+        assert!(
+            !cache
+                .replenish(program2, new_test_loaded_program(5, 6), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program2, new_test_loaded_program(11, 12), u64::MAX)
+                .0
+        );
 
         let program3 = Pubkey::new_unique();
-        assert!(!cache.replenish(program3, new_test_loaded_program(25, 26)).0);
+        assert!(
+            !cache
+                .replenish(program3, new_test_loaded_program(25, 26), u64::MAX)
+                .0
+        );
 
         // Testing fork 0 - 5 - 11 - 15 - 16 - 19 - 21 - 23 with current slot at 19
         let mut missing = vec![
@@ -2161,12 +2271,28 @@ mod tests {
         cache.set_fork_graph(fork_graph);
 
         let program1 = Pubkey::new_unique();
-        assert!(!cache.replenish(program1, new_test_loaded_program(0, 1)).0);
-        assert!(!cache.replenish(program1, new_test_loaded_program(20, 21)).0);
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(0, 1), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(20, 21), u64::MAX)
+                .0
+        );
 
         let program2 = Pubkey::new_unique();
-        assert!(!cache.replenish(program2, new_test_loaded_program(5, 6)).0);
-        assert!(!cache.replenish(program2, new_test_loaded_program(11, 12)).0);
+        assert!(
+            !cache
+                .replenish(program2, new_test_loaded_program(5, 6), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program2, new_test_loaded_program(11, 12), u64::MAX)
+                .0
+        );
 
         let program3 = Pubkey::new_unique();
         // Insert an unloaded program with correct/cache's environment at slot 25
@@ -2183,7 +2309,8 @@ mod tests {
                         new_test_loaded_program(20, 21)
                             .to_unloaded()
                             .expect("Failed to create unloaded program")
-                    )
+                    ),
+                    u64::MAX
                 )
                 .0
         );
@@ -2258,15 +2385,35 @@ mod tests {
         cache.set_fork_graph(fork_graph);
 
         let program1 = Pubkey::new_unique();
-        assert!(!cache.replenish(program1, new_test_loaded_program(10, 11)).0);
-        assert!(!cache.replenish(program1, new_test_loaded_program(20, 21)).0);
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(10, 11), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(20, 21), u64::MAX)
+                .0
+        );
 
         let program2 = Pubkey::new_unique();
-        assert!(!cache.replenish(program2, new_test_loaded_program(5, 6)).0);
-        assert!(!cache.replenish(program2, new_test_loaded_program(11, 12)).0);
+        assert!(
+            !cache
+                .replenish(program2, new_test_loaded_program(5, 6), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program2, new_test_loaded_program(11, 12), u64::MAX)
+                .0
+        );
 
         let program3 = Pubkey::new_unique();
-        assert!(!cache.replenish(program3, new_test_loaded_program(25, 26)).0);
+        assert!(
+            !cache
+                .replenish(program3, new_test_loaded_program(25, 26), u64::MAX)
+                .0
+        );
 
         // The following is a special case, where there's an expiration slot
         let test_program = Arc::new(LoadedProgram {
@@ -2278,7 +2425,7 @@ mod tests {
             tx_usage_counter: AtomicU64::default(),
             ix_usage_counter: AtomicU64::default(),
         });
-        assert!(!cache.replenish(program1, test_program).0);
+        assert!(!cache.replenish(program1, test_program, u64::MAX).0);
 
         // Testing fork 0 - 5 - 11 - 15 - 16 - 19 - 21 - 23 with current slot at 19
         let mut missing = vec![
@@ -2362,8 +2509,16 @@ mod tests {
         cache.set_fork_graph(fork_graph);
 
         let program1 = Pubkey::new_unique();
-        assert!(!cache.replenish(program1, new_test_loaded_program(0, 1)).0);
-        assert!(!cache.replenish(program1, new_test_loaded_program(5, 6)).0);
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(0, 1), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(5, 6), u64::MAX)
+                .0
+        );
 
         cache.prune(10, 0);
 
@@ -2402,11 +2557,23 @@ mod tests {
         cache.set_fork_graph(fork_graph);
 
         let program1 = Pubkey::new_unique();
-        assert!(!cache.replenish(program1, new_test_loaded_program(0, 1)).0);
-        assert!(!cache.replenish(program1, new_test_loaded_program(5, 6)).0);
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(0, 1), u64::MAX)
+                .0
+        );
+        assert!(
+            !cache
+                .replenish(program1, new_test_loaded_program(5, 6), u64::MAX)
+                .0
+        );
 
         let program2 = Pubkey::new_unique();
-        assert!(!cache.replenish(program2, new_test_loaded_program(10, 11)).0);
+        assert!(
+            !cache
+                .replenish(program2, new_test_loaded_program(10, 11), u64::MAX)
+                .0
+        );
 
         let mut missing = vec![
             (program1, (LoadedProgramMatchCriteria::NoCriteria, 1)),
diff --git a/runtime/src/bank.rs b/runtime/src/bank.rs
index b53f037db4..8ed13611e8 100644
--- a/runtime/src/bank.rs
+++ b/runtime/src/bank.rs
@@ -1472,7 +1472,7 @@ impl Bank {
                     drop(loaded_programs_cache);
                     let recompiled = new.load_program(&key, false, Some(program_to_recompile));
                     let mut loaded_programs_cache = new.loaded_programs_cache.write().unwrap();
-                    loaded_programs_cache.replenish(key, recompiled);
+                    loaded_programs_cache.replenish(key, recompiled, new.slot());
                 }
             } else if new.epoch() != loaded_programs_cache.latest_root_epoch
                 || slot_index.saturating_add(slots_in_recompilation_phase) >= slots_in_epoch
@@ -4378,6 +4378,7 @@ impl Bank {
             &mut timings,
             Some(&account_overrides),
             None,
+            true,
         );
 
         let post_simulation_accounts = loaded_transactions
@@ -5047,6 +5048,7 @@ impl Bank {
     fn replenish_program_cache(
         &self,
         program_accounts_map: &HashMap<Pubkey, (&Pubkey, u64)>,
+        limit_to_load_programs: bool,
     ) -> LoadedProgramsForTxBatch {
         let mut missing_programs: Vec<(Pubkey, (LoadedProgramMatchCriteria, u64))> =
             if self.check_program_modification_slot {
@@ -5092,11 +5094,16 @@ impl Bank {
                 }
                 // Submit our last completed loading task.
                 if let Some((key, program)) = program_to_store.take() {
-                    loaded_programs_cache.finish_cooperative_loading_task(
+                    if loaded_programs_cache.finish_cooperative_loading_task(
                         self.slot(),
                         key,
                         program,
-                    );
+                    ) && limit_to_load_programs
+                    {
+                        let mut ret = LoadedProgramsForTxBatch::default();
+                        ret.hit_max_limit = true;
+                        return ret;
+                    }
                 }
                 // Figure out which program needs to be loaded next.
                 let program_to_load = loaded_programs_cache.extract(
@@ -5128,7 +5135,7 @@ impl Bank {
         loaded_programs_for_txs.unwrap()
     }
 
-    #[allow(clippy::type_complexity)]
+    #[allow(clippy::too_many_arguments, clippy::type_complexity)]
     pub fn load_and_execute_transactions(
         &self,
         batch: &TransactionBatch,
@@ -5139,6 +5146,7 @@ impl Bank {
         timings: &mut ExecuteTimings,
         account_overrides: Option<&AccountOverrides>,
         log_messages_bytes_limit: Option<usize>,
+        limit_to_load_programs: bool,
     ) -> LoadAndExecuteTransactionsOutput {
         let sanitized_txs = batch.sanitized_transactions();
         debug!("processing transactions: {}", sanitized_txs.len());
@@ -5208,9 +5216,22 @@ impl Bank {
         }
 
         let programs_loaded_for_tx_batch = Rc::new(RefCell::new(
-            self.replenish_program_cache(&program_accounts_map),
+            self.replenish_program_cache(&program_accounts_map, limit_to_load_programs),
         ));
 
+        if programs_loaded_for_tx_batch.borrow().hit_max_limit {
+            return LoadAndExecuteTransactionsOutput {
+                loaded_transactions: vec![],
+                execution_results: vec![],
+                retryable_transaction_indexes: vec![],
+                executed_transactions_count: 0,
+                executed_non_vote_transactions_count: 0,
+                executed_with_successful_result_count: 0,
+                signature_count: 0,
+                error_counters,
+            };
+        }
+
         let mut load_time = Measure::start("accounts_load");
         let mut loaded_transactions = self.rc.accounts.load_accounts(
             &self.ancestors,
@@ -6309,6 +6330,7 @@ impl Bank {
             timings,
             None,
             log_messages_bytes_limit,
+            false,
         );
 
         let (last_blockhash, lamports_per_signature) =
@@ -7772,10 +7794,11 @@ impl Bank {
         debug!("Adding program {} under {:?}", name, program_id);
         self.add_builtin_account(name.as_str(), &program_id, false);
         self.builtin_programs.insert(program_id);
-        self.loaded_programs_cache
-            .write()
-            .unwrap()
-            .replenish(program_id, Arc::new(builtin));
+        self.loaded_programs_cache.write().unwrap().replenish(
+            program_id,
+            Arc::new(builtin),
+            self.slot,
+        );
         debug!("Added program {} under {:?}", name, program_id);
     }
 
-- 
2.25.1

